// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package database

import (
	"context"
	"time"
)

const batchUpdateTournamentPlayers = `-- name: BatchUpdateTournamentPlayers :exec
WITH players_data (
    id,
    score,
    scores,
    streak
    ) AS (
    SELECT
        (data->>'id')::int,
        (data->>'score')::int,
        (SELECT array_agg(value::int)
         FROM jsonb_array_elements(data->'scores') AS score_elements(value)),
        (data->>'streak')::int
    FROM jsonb_array_elements($2::jsonb) AS data
        )
UPDATE tournament_players t
SET score = players_data.score,
    scores = players_data.scores,
    streak = players_data.streak
FROM players_data
WHERE t.tournament_id = $1 AND t.player_id = players_data.id
`

type BatchUpdateTournamentPlayersParams struct {
	TournamentID string
	PlayersInput []byte
}

func (q *Queries) BatchUpdateTournamentPlayers(ctx context.Context, arg BatchUpdateTournamentPlayersParams) error {
	_, err := q.db.Exec(ctx, batchUpdateTournamentPlayers, arg.TournamentID, arg.PlayersInput)
	return err
}

const createGame = `-- name: CreateGame :exec
INSERT INTO games (
                   id,
                   base_time,
                   increment,
                   tournament_id,
                   white_id,
                   black_id,
                   rating_w,
                   rating_b
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateGameParams struct {
	ID           string
	BaseTime     int32
	Increment    int32
	TournamentID *string
	WhiteID      *int32
	BlackID      *int32
	RatingW      int32
	RatingB      int32
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) error {
	_, err := q.db.Exec(ctx, createGame,
		arg.ID,
		arg.BaseTime,
		arg.Increment,
		arg.TournamentID,
		arg.WhiteID,
		arg.BlackID,
		arg.RatingW,
		arg.RatingB,
	)
	return err
}

const createTournament = `-- name: CreateTournament :exec
INSERT INTO tournaments (id, name, start_time, duration, base_time, increment, created_by, berserk_allowed) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateTournamentParams struct {
	ID             string
	Name           string
	StartTime      time.Time
	Duration       int32
	BaseTime       int32
	Increment      int32
	CreatedBy      *int32
	BerserkAllowed bool
}

func (q *Queries) CreateTournament(ctx context.Context, arg CreateTournamentParams) error {
	_, err := q.db.Exec(ctx, createTournament,
		arg.ID,
		arg.Name,
		arg.StartTime,
		arg.Duration,
		arg.BaseTime,
		arg.Increment,
		arg.CreatedBy,
		arg.BerserkAllowed,
	)
	return err
}

const deleteLiveGames = `-- name: DeleteLiveGames :exec
DELETE FROM games WHERE result = 0
`

func (q *Queries) DeleteLiveGames(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteLiveGames)
	return err
}

const deleteLiveTournaments = `-- name: DeleteLiveTournaments :exec
DELETE FROM tournaments WHERE status = 1
`

func (q *Queries) DeleteLiveTournaments(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteLiveTournaments)
	return err
}

const deleteTournamentPlayer = `-- name: DeleteTournamentPlayer :exec
DELETE FROM tournament_players WHERE tournament_id = $1 AND player_id = $2
`

type DeleteTournamentPlayerParams struct {
	TournamentID string
	PlayerID     int32
}

func (q *Queries) DeleteTournamentPlayer(ctx context.Context, arg DeleteTournamentPlayerParams) error {
	_, err := q.db.Exec(ctx, deleteTournamentPlayer, arg.TournamentID, arg.PlayerID)
	return err
}

const endGameWithResult = `-- name: EndGameWithResult :exec
UPDATE games
SET result = $1, method = $2, change_w = $3, change_b = $4, game_length = $5, end_time_left_white = $6, end_time_left_black = $7, berserk_white = $8, berserk_black = $9
WHERE id = $10
`

type EndGameWithResultParams struct {
	Result           int32
	Method           int32
	ChangeW          *int32
	ChangeB          *int32
	GameLength       int32
	EndTimeLeftWhite *int32
	EndTimeLeftBlack *int32
	BerserkWhite     bool
	BerserkBlack     bool
	ID               string
}

func (q *Queries) EndGameWithResult(ctx context.Context, arg EndGameWithResultParams) error {
	_, err := q.db.Exec(ctx, endGameWithResult,
		arg.Result,
		arg.Method,
		arg.ChangeW,
		arg.ChangeB,
		arg.GameLength,
		arg.EndTimeLeftWhite,
		arg.EndTimeLeftBlack,
		arg.BerserkWhite,
		arg.BerserkBlack,
		arg.ID,
	)
	return err
}

const getGameByID = `-- name: GetGameByID :one
SELECT id FROM games WHERE id = $1
`

func (q *Queries) GetGameByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, getGameByID, id)
	err := row.Scan(&id)
	return id, err
}

const getGameInfo = `-- name: GetGameInfo :one
SELECT
    games.id, games.base_time, games.increment, games.tournament_id, games.white_id, games.black_id, games.game_length, games.result, games.created_at, games.end_time_left_white, games.end_time_left_black, games.method, games.rating_w, games.rating_b, games.change_w, games.change_b, games.berserk_white, games.berserk_black,
    u1.username as white_username,
    u2.username as black_username,
    t.name as tournament_name
FROM games
LEFT OUTER JOIN tournaments t ON games.tournament_id = t.id
LEFT OUTER JOIN users u1 ON games.white_id = u1.id
LEFT OUTER JOIN users u2 ON games.black_id = u2.id
WHERE games.id = $1
`

type GetGameInfoRow struct {
	ID               string
	BaseTime         int32
	Increment        int32
	TournamentID     *string
	WhiteID          *int32
	BlackID          *int32
	GameLength       int32
	Result           int32
	CreatedAt        time.Time
	EndTimeLeftWhite *int32
	EndTimeLeftBlack *int32
	Method           int32
	RatingW          int32
	RatingB          int32
	ChangeW          *int32
	ChangeB          *int32
	BerserkWhite     bool
	BerserkBlack     bool
	WhiteUsername    *string
	BlackUsername    *string
	TournamentName   *string
}

func (q *Queries) GetGameInfo(ctx context.Context, id string) (GetGameInfoRow, error) {
	row := q.db.QueryRow(ctx, getGameInfo, id)
	var i GetGameInfoRow
	err := row.Scan(
		&i.ID,
		&i.BaseTime,
		&i.Increment,
		&i.TournamentID,
		&i.WhiteID,
		&i.BlackID,
		&i.GameLength,
		&i.Result,
		&i.CreatedAt,
		&i.EndTimeLeftWhite,
		&i.EndTimeLeftBlack,
		&i.Method,
		&i.RatingW,
		&i.RatingB,
		&i.ChangeW,
		&i.ChangeB,
		&i.BerserkWhite,
		&i.BerserkBlack,
		&i.WhiteUsername,
		&i.BlackUsername,
		&i.TournamentName,
	)
	return i, err
}

const getGameMoves = `-- name: GetGameMoves :many
SELECT move_number, move_notation, orig, dest, move_fen, time_left
FROM moves
WHERE game_id = $1
ORDER BY move_number
`

type GetGameMovesRow struct {
	MoveNumber   int32
	MoveNotation string
	Orig         string
	Dest         string
	MoveFen      string
	TimeLeft     *int32
}

func (q *Queries) GetGameMoves(ctx context.Context, gameID string) ([]GetGameMovesRow, error) {
	rows, err := q.db.Query(ctx, getGameMoves, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGameMovesRow{}
	for rows.Next() {
		var i GetGameMovesRow
		if err := rows.Scan(
			&i.MoveNumber,
			&i.MoveNotation,
			&i.Orig,
			&i.Dest,
			&i.MoveFen,
			&i.TimeLeft,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameNumbers = `-- name: GetGameNumbers :one
WITH target_user AS (
    SELECT id FROM users WHERE username = $1
),
     user_games AS (
         SELECT g.id, g.base_time, g.increment, g.tournament_id, g.white_id, g.black_id, g.game_length, g.result, g.created_at, g.end_time_left_white, g.end_time_left_black, g.method, g.rating_w, g.rating_b, g.change_w, g.change_b, g.berserk_white, g.berserk_black, true AS is_white
         FROM games g, target_user u
         WHERE g.white_id = u.id
         UNION ALL
         SELECT g.id, g.base_time, g.increment, g.tournament_id, g.white_id, g.black_id, g.game_length, g.result, g.created_at, g.end_time_left_white, g.end_time_left_black, g.method, g.rating_w, g.rating_b, g.change_w, g.change_b, g.berserk_white, g.berserk_black, false AS is_white
         FROM games g, target_user u
         WHERE g.black_id = u.id
     )
SELECT
    COUNT(*) AS game_count,
    COUNT(*) FILTER(WHERE (is_white AND result = 1) OR (NOT is_white AND result = 2)) AS win_count,
    COUNT(*) FILTER(WHERE result = 3) AS draw_count,
    COUNT(*) FILTER(WHERE (is_white AND result = 2) OR (NOT is_white AND result = 1)) AS loss_count
FROM user_games
`

type GetGameNumbersRow struct {
	GameCount int64
	WinCount  int64
	DrawCount int64
	LossCount int64
}

func (q *Queries) GetGameNumbers(ctx context.Context, username *string) (GetGameNumbersRow, error) {
	row := q.db.QueryRow(ctx, getGameNumbers, username)
	var i GetGameNumbersRow
	err := row.Scan(
		&i.GameCount,
		&i.WinCount,
		&i.DrawCount,
		&i.LossCount,
	)
	return i, err
}

const getLiveGames = `-- name: GetLiveGames :many
SELECT id, base_time, increment, tournament_id, white_id, black_id, game_length, result, created_at, end_time_left_white, end_time_left_black, method, rating_w, rating_b, change_w, change_b, berserk_white, berserk_black FROM games WHERE result = 0
`

func (q *Queries) GetLiveGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, getLiveGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.BaseTime,
			&i.Increment,
			&i.TournamentID,
			&i.WhiteID,
			&i.BlackID,
			&i.GameLength,
			&i.Result,
			&i.CreatedAt,
			&i.EndTimeLeftWhite,
			&i.EndTimeLeftBlack,
			&i.Method,
			&i.RatingW,
			&i.RatingB,
			&i.ChangeW,
			&i.ChangeB,
			&i.BerserkWhite,
			&i.BerserkBlack,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLiveTournaments = `-- name: GetLiveTournaments :many
SELECT id, name, start_time, duration, base_time, increment, status, berserk_allowed, created_by FROM tournaments WHERE status = 1 ORDER BY start_time
`

func (q *Queries) GetLiveTournaments(ctx context.Context) ([]Tournament, error) {
	rows, err := q.db.Query(ctx, getLiveTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournament{}
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartTime,
			&i.Duration,
			&i.BaseTime,
			&i.Increment,
			&i.Status,
			&i.BerserkAllowed,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerGames = `-- name: GetPlayerGames :many
SELECT t.name as tournament_name, t.id as tournament_id, games.id, games.base_time, games.increment, u1.username as white_username, u2.username as black_username, games.result, games.game_length, games.method, games.created_at, games.rating_w, games.rating_b, games.change_w, games.change_b, games.berserk_white, games.berserk_black
FROM games
JOIN users u1 ON games.white_id = u1.id
JOIN users u2 ON games.black_id = u2.id
LEFT OUTER JOIN tournaments t ON games.tournament_id = t.id
WHERE (u1.username = $1 OR u2.username = $1)
ORDER BY games.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPlayerGamesParams struct {
	Username *string
	Limit    int32
	Offset   int32
}

type GetPlayerGamesRow struct {
	TournamentName *string
	TournamentID   *string
	ID             string
	BaseTime       int32
	Increment      int32
	WhiteUsername  *string
	BlackUsername  *string
	Result         int32
	GameLength     int32
	Method         int32
	CreatedAt      time.Time
	RatingW        int32
	RatingB        int32
	ChangeW        *int32
	ChangeB        *int32
	BerserkWhite   bool
	BerserkBlack   bool
}

func (q *Queries) GetPlayerGames(ctx context.Context, arg GetPlayerGamesParams) ([]GetPlayerGamesRow, error) {
	rows, err := q.db.Query(ctx, getPlayerGames, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlayerGamesRow{}
	for rows.Next() {
		var i GetPlayerGamesRow
		if err := rows.Scan(
			&i.TournamentName,
			&i.TournamentID,
			&i.ID,
			&i.BaseTime,
			&i.Increment,
			&i.WhiteUsername,
			&i.BlackUsername,
			&i.Result,
			&i.GameLength,
			&i.Method,
			&i.CreatedAt,
			&i.RatingW,
			&i.RatingB,
			&i.ChangeW,
			&i.ChangeB,
			&i.BerserkWhite,
			&i.BerserkBlack,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledTournaments = `-- name: GetScheduledTournaments :many
SELECT id, name, start_time, duration, base_time, increment, status, berserk_allowed, created_by FROM tournaments WHERE status = 0 ORDER BY start_time
`

func (q *Queries) GetScheduledTournaments(ctx context.Context) ([]Tournament, error) {
	rows, err := q.db.Query(ctx, getScheduledTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournament{}
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartTime,
			&i.Duration,
			&i.BaseTime,
			&i.Increment,
			&i.Status,
			&i.BerserkAllowed,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentByID = `-- name: GetTournamentByID :one
SELECT id FROM tournaments WHERE id = $1
`

func (q *Queries) GetTournamentByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, getTournamentByID, id)
	err := row.Scan(&id)
	return id, err
}

const getTournamentInfo = `-- name: GetTournamentInfo :one
SELECT t.id, t.name, t.start_time, t.duration, t.base_time, t.increment, t.status, t.berserk_allowed, t.created_by, u.username FROM tournaments t JOIN users u ON t.created_by = u.id WHERE t.id = $1
`

type GetTournamentInfoRow struct {
	ID             string
	Name           string
	StartTime      time.Time
	Duration       int32
	BaseTime       int32
	Increment      int32
	Status         int32
	BerserkAllowed bool
	CreatedBy      *int32
	Username       *string
}

func (q *Queries) GetTournamentInfo(ctx context.Context, id string) (GetTournamentInfoRow, error) {
	row := q.db.QueryRow(ctx, getTournamentInfo, id)
	var i GetTournamentInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartTime,
		&i.Duration,
		&i.BaseTime,
		&i.Increment,
		&i.Status,
		&i.BerserkAllowed,
		&i.CreatedBy,
		&i.Username,
	)
	return i, err
}

const getTournamentPlayer = `-- name: GetTournamentPlayer :one
SELECT id FROM tournament_players WHERE tournament_id = $1 AND player_id = $2
`

type GetTournamentPlayerParams struct {
	TournamentID string
	PlayerID     int32
}

func (q *Queries) GetTournamentPlayer(ctx context.Context, arg GetTournamentPlayerParams) (int32, error) {
	row := q.db.QueryRow(ctx, getTournamentPlayer, arg.TournamentID, arg.PlayerID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getTournamentPlayers = `-- name: GetTournamentPlayers :many
SELECT tp.score, tp.streak, u.id, u.username, u.rating, tp.scores FROM tournament_players tp JOIN users u ON tp.player_id = u.id WHERE tp.tournament_id = $1
`

type GetTournamentPlayersRow struct {
	Score    *int32
	Streak   *int32
	ID       int32
	Username *string
	Rating   float64
	Scores   []int32
}

func (q *Queries) GetTournamentPlayers(ctx context.Context, tournamentID string) ([]GetTournamentPlayersRow, error) {
	rows, err := q.db.Query(ctx, getTournamentPlayers, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTournamentPlayersRow{}
	for rows.Next() {
		var i GetTournamentPlayersRow
		if err := rows.Scan(
			&i.Score,
			&i.Streak,
			&i.ID,
			&i.Username,
			&i.Rating,
			&i.Scores,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentStatus = `-- name: GetTournamentStatus :one
SELECT status FROM tournaments WHERE id = $1
`

func (q *Queries) GetTournamentStatus(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRow(ctx, getTournamentStatus, id)
	var status int32
	err := row.Scan(&status)
	return status, err
}

type InsertMovesParams struct {
	GameID       string
	MoveNumber   int32
	MoveNotation string
	Orig         string
	Dest         string
	MoveFen      string
	TimeLeft     *int32
}

const insertTournamentPlayer = `-- name: InsertTournamentPlayer :exec
INSERT INTO tournament_players (player_id, tournament_id) VALUES ($1, $2)
`

type InsertTournamentPlayerParams struct {
	PlayerID     int32
	TournamentID string
}

func (q *Queries) InsertTournamentPlayer(ctx context.Context, arg InsertTournamentPlayerParams) error {
	_, err := q.db.Exec(ctx, insertTournamentPlayer, arg.PlayerID, arg.TournamentID)
	return err
}

const updateTournamentStartTime = `-- name: UpdateTournamentStartTime :exec
UPDATE tournaments SET start_time = CURRENT_TIMESTAMP where id = $1
`

func (q *Queries) UpdateTournamentStartTime(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, updateTournamentStartTime, id)
	return err
}

const updateTournamentStatus = `-- name: UpdateTournamentStatus :exec
UPDATE tournaments SET status = $1 WHERE id=$2
`

type UpdateTournamentStatusParams struct {
	Status int32
	ID     string
}

func (q *Queries) UpdateTournamentStatus(ctx context.Context, arg UpdateTournamentStatusParams) error {
	_, err := q.db.Exec(ctx, updateTournamentStatus, arg.Status, arg.ID)
	return err
}
